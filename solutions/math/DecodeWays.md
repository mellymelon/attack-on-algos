# [Decode Ways](https://leetcode.com/problems/decode-ways/)

求给定数字有多少种解读方式。

数字可以解读为一个或多个字母，注意`0`不能解读成任何字母。

## 举个栗子🌰
```java
"0122" -> 0 //'0'开头的数字不用解读
"10" -> 1 //不能拆成'1'和'0'
"2216" -> 5 //可以解读成"2 2 1 6"、"2 2 16"、"2 21 6"、"22 1 6"、"22 16"
```

## 思路

![p91_2.jpg](/pictures/p91_2.jpg)

如果当前数字不为`0`，那么前面有多少种解读方式，在加上当前数字后，至少也有这么多种解读方式。

比如`22`有2种解读方式，加上`1`变成`221`，至少有2种解读方式。

此外，如果当前数字能和前一个数字结合成表示字母的数字，那么前面有多少种解读方式，在加上当前组合的二位数字后，也有这么多种解读方式。

比如`2`有1种解读方式，加上`21`变成`221`，有1种解读方式。

综上，`221`有3种解读方式。

因为计算需要基于之前的结果，这个过程可以用动态规划实现，如下图：

![p91](/pictures/p91.jpg)

公式是`dp[i] = dp[i-1] + dp[i-2]`。基于这个公式还要考虑`0`作变化。

## 题解

```py
#py,32ms,95%/14.2MB,19%
def numDecodings(self, s):
    if s[0] == '0': return 0 #以'0'开始就不能解读
    N = len(s)
    dp = [0] * (N + 1) #多出一个位置给空字符串
    dp[0] = dp[1] = 1 #空字符串和一个数字都只有1种解读方式。dp[0]也可以理解为其他数字和""合并只有1种方式
    for i in range(2, N + 1): #注意下文里s[i-1]表示当前数字，而不是s[i]。因为已经dp了空串和s[0]，-1才能匹配s当前的数字位置
        if s[i-1] != '0': dp[i] = dp[i-1] #当前数字不是'0'就可以基于i-1个数字的dp结果。如果是'0'它就一定要和上个数字合并，就不能基于上个位置的dp结果。另外这里=和+=都可以
        if 10 <= int(s[i-2:i]) <= 26: dp[i] += dp[i-2] #如果当前数字能和上个数字构成[10,26]范围内的数字，就可以加上i-2位置的dp结果
    return dp[-1]
```

```go
//go,0ms,100%/2MB,45%
func numDecodings(s string) int {
    if s[0] == '0' { return 0 }
    N := len(s)
    dp := make([]int, N + 1)
    dp[0] = 1
    dp[1] = 1
    for i := 2; i <= N; i++ {
        if s[i - 1] != '0' { dp[i] = dp[i - 1] }
        sub := (s[i - 2] - '0') * 10 + (s[i - 1] - '0')
        if 10 <= sub && sub <= 26 { dp[i] += dp[i - 2] }
    }
    return dp[N]
}
```

2021.7.5 by Yong